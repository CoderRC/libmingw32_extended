diff --git a/.gitignore b/.gitignore
index 7495f5a..3745cd9 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,6 +1,4 @@
 .vscode
 build/
-source/poll.c
-include/poll.h
 .gitignore
 .ssh
\ No newline at end of file
diff --git a/configure b/configure
index 13b8d07..f69b516 100755
--- a/configure
+++ b/configure
@@ -24,6 +24,7 @@ SOURCES='
 \$(srcdir)/source/dlerror.c
 \$(srcdir)/source/dladdr.c
 \$(srcdir)/source/poll.c
+\$(srcdir)/source/ppoll.c
 \$(srcdir)/source/posix_spawn.c
 \$(srcdir)/source/posix_spawnp.c
 \$(srcdir)/source/posix_spawn_file_actions_addclose.c
diff --git a/output.txt b/output.txt
index 579aa1b..e69de29 100644
--- a/output.txt
+++ b/output.txt
@@ -1,206 +0,0 @@
-diff --git a/.gitignore b/.gitignore
-index 474e379..7495f5a 100644
---- a/.gitignore
-+++ b/.gitignore
-@@ -1,2 +1,6 @@
- .vscode
--build/
-\ No newline at end of file
-+build/
-+source/poll.c
-+include/poll.h
-+.gitignore
-+.ssh
-\ No newline at end of file
-diff --git a/configure b/configure
-index 9f75ec9..13b8d07 100755
---- a/configure
-+++ b/configure
-@@ -23,6 +23,7 @@ SOURCES='
- \$(srcdir)/source/dlsym.c
- \$(srcdir)/source/dlerror.c
- \$(srcdir)/source/dladdr.c
-+\$(srcdir)/source/poll.c
- \$(srcdir)/source/posix_spawn.c
- \$(srcdir)/source/posix_spawnp.c
- \$(srcdir)/source/posix_spawn_file_actions_addclose.c
-@@ -47,7 +48,22 @@ SOURCES='
- \$(srcdir)/source/accept.c
- \$(srcdir)/source/bind.c
- \$(srcdir)/source/connect.c
-+\$(srcdir)/source/endhostent.c
-+\$(srcdir)/source/endnetent.c
-+\$(srcdir)/source/endprotoent.c
-+\$(srcdir)/source/endservent.c
-+\$(srcdir)/source/gethostent.c
- \$(srcdir)/source/getaddrinfo.c
-+\$(srcdir)/source/getnameinfo.c
-+\$(srcdir)/source/getprotobyname.c
-+\$(srcdir)/source/getprotobynumber.c
-+\$(srcdir)/source/getprotoent.c
-+\$(srcdir)/source/getservbyname.c
-+\$(srcdir)/source/getservbyport.c
-+\$(srcdir)/source/getservent.c
-+\$(srcdir)/source/getnetbyaddr.c
-+\$(srcdir)/source/getnetbyname.c
-+\$(srcdir)/source/getnetent.c
- \$(srcdir)/source/freeaddrinfo.c
- \$(srcdir)/source/getpeername.c
- \$(srcdir)/source/getsockname.c
-@@ -69,9 +85,14 @@ SOURCES='
- \$(srcdir)/source/sendto.c
- \$(srcdir)/source/setsockopt.c
- \$(srcdir)/source/shutdown.c
-+\$(srcdir)/source/sethostent.c
-+\$(srcdir)/source/setnetent.c
-+\$(srcdir)/source/setprotoent.c
-+\$(srcdir)/source/setservent.c
- \$(srcdir)/source/socket.c
- \$(srcdir)/source/socketpair.c
- \$(srcdir)/source/gai_strerror.c
-+\$(srcdir)/source/test_all_netdb.c
- '
- INCLUDE_DIRECTORIES='
- include
-@@ -89,6 +110,7 @@ include/sys/wait.h
- include/dlfcn.h
- include/spawn.h
- include/netdb.h
-+include/poll.h
- '
- ac_subst_vars=$ac_subst_vars'
- SOURCES
-diff --git a/include/netdb.h b/include/netdb.h
-index 62051dd..d376728 100644
---- a/include/netdb.h
-+++ b/include/netdb.h
-@@ -9,6 +9,10 @@ extern "C" {
- 
- #include <sys/socket.h>
- #include <netinet/in.h>
-+#include <inttypes.h>
-+
-+/* Reserved port number */
-+#define IPPORT_RESERVED 1024
- 
- /* Error codes for getaddrinfo */
- #define EAI_SUCCESS     0   /* Success */
-@@ -20,6 +24,8 @@ extern "C" {
- #define EAI_MEMORY      6   /* Memory allocation failure */
- #define EAI_SERVICE     8   /* Servname not supported for ai_socktype */
- #define EAI_SOCKTYPE    10  /* ai_socktype not supported */
-+#define EAI_SYSTEM      11  /* System error */
-+#define EAI_OVERFLOW    12  /* Argument buffer overflow */
- 
- /* Address info flags */
- #define AI_PASSIVE      0x00000001  /* Socket address is intended for bind */
-@@ -30,6 +36,46 @@ extern "C" {
- #define AI_ALL          0x00000100  /* Return all addresses (IPv4 and IPv6) */
- #define AI_ADDRCONFIG   0x00000400  /* Use addresses matching local configuration */
- 
-+/* getnameinfo flags */
-+#define NI_NOFQDN       0x00000001  /* Only nodename portion for local hosts */
-+#define NI_NUMERICHOST  0x00000002  /* Numeric form of hostname */
-+#define NI_NAMEREQD     0x00000004  /* Error if hostname not found */
-+#define NI_NUMERICSERV  0x00000008  /* Numeric form of service */
-+#define NI_NUMERICSCOPE 0x00000020  /* Numeric form of scope */
-+#define NI_DGRAM        0x00000010  /* Service is datagram */
-+
-+/* Host entry structure */
-+struct hostent {
-+    char *h_name;       /* Official name of host */
-+    char **h_aliases;   /* Alias list */
-+    int h_addrtype;     /* Address type */
-+    int h_length;       /* Length of address */
-+    char **h_addr_list; /* List of addresses */
-+};
-+
-+/* Network entry structure */
-+struct netent {
-+    char *n_name;       /* Official name of network */
-+    char **n_aliases;   /* Alias list */
-+    int n_addrtype;     /* Net address type */
-+    uint32_t n_net;     /* Network number */
-+};
-+
-+/* Protocol entry structure */
-+struct protoent {
-+    char *p_name;       /* Official protocol name */
-+    char **p_aliases;   /* Alias list */
-+    int p_proto;        /* Protocol number */
-+};
-+
-+/* Service entry structure */
-+struct servent {
-+    char *s_name;       /* Official service name */
-+    char **s_aliases;   /* Alias list */
-+    int s_port;         /* Port number */
-+    char *s_proto;      /* Protocol to use */
-+};
-+
- /* Structure for address information */
- struct addrinfo {
-     int ai_flags;               /* Input flags (AI_*) */
-@@ -49,6 +95,35 @@ int getaddrinfo(const char *restrict nodename,
-                 struct addrinfo **restrict res);
- void freeaddrinfo(struct addrinfo *res);
- const char *gai_strerror(int errcode);
-+int getnameinfo(const struct sockaddr *restrict addr, socklen_t addrlen,
-+                char *restrict host, socklen_t hostlen,
-+                char *restrict serv, socklen_t servlen, int flags);
-+
-+/* Host database functions */
-+void endhostent(void);
-+struct hostent *gethostent(void);
-+void sethostent(int stayopen);
-+
-+/* Network database functions */
-+void endnetent(void);
-+struct netent *getnetbyaddr(uint32_t net, int type);
-+struct netent *getnetbyname(const char *name);
-+struct netent *getnetent(void);
-+void setnetent(int stayopen);
-+
-+/* Protocol database functions */
-+void endprotoent(void);
-+struct protoent *getprotobyname(const char *name);
-+struct protoent *getprotobynumber(int proto);
-+struct protoent *getprotoent(void);
-+void setprotoent(int stayopen);
-+
-+/* Service database functions */
-+void endservent(void);
-+struct servent *getservbyname(const char *name, const char *proto);
-+struct servent *getservbyport(int port, const char *proto);
-+struct servent *getservent(void);
-+void setservent(int stayopen);
- 
- #ifdef __cplusplus
- }
-diff --git a/include/spawn.h b/include/spawn.h
-index 7753d56..6c98384 100644
---- a/include/spawn.h
-+++ b/include/spawn.h
-@@ -1,7 +1,10 @@
- /* spawn.h
- */
- #ifndef _SPAWN_H
--#define _SPAWN_H
-+#ifdef __argv
-+#define _SPAWN_H __argv
-+#undef __argv
-+#endif
- 
- #ifdef __cplusplus
- extern "C"
-@@ -116,4 +119,10 @@ extern "C"
- }
- #endif				/* __cplusplus */
- 
-+#ifdef _SPAWN_H
-+#define __argv _SPAWN_H
-+#else
-+#define _SPAWN_H
-+#endif
-+
- #endif				/* spawn.h */
diff --git a/source/test_poll.c b/source/test_poll.c
index 1d4c462..eb09cb0 100644
--- a/source/test_poll.c
+++ b/source/test_poll.c
@@ -7,12 +7,13 @@
 #include <signal.h>
 #include <time.h>
 #include <errno.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
 
 #define TIMEOUT_MS 2000
 #define TEST_PASSED 0
 #define TEST_FAILED 1
 
-// Helper function to describe poll events
 const char* describe_events(short events) {
     static char buffer[256];
     char* ptr = buffer;
@@ -29,11 +30,10 @@ const char* describe_events(short events) {
     if (events & POLLNVAL) ptr += sprintf(ptr, "POLLNVAL|");
     
     if (ptr == buffer) return "NONE";
-    *(ptr - 1) = '\0';  // Remove trailing '|'
+    *(ptr - 1) = '\0';
     return buffer;
 }
 
-// Test case 1: Basic read readiness
 int test_read_ready() {
     int pipefd[2];
     struct pollfd fds[1];
@@ -43,11 +43,9 @@ int test_read_ready() {
         return TEST_FAILED;
     }
     
-    // Set up poll structure
     fds[0].fd = pipefd[0];
     fds[0].events = POLLIN;
     
-    // Write data to make pipe readable
     write(pipefd[1], "test", 4);
     
     int ret = poll(fds, 1, TIMEOUT_MS);
@@ -72,7 +70,6 @@ int test_read_ready() {
     return TEST_PASSED;
 }
 
-// Test case 2: Basic write readiness
 int test_write_ready() {
     struct pollfd fds[1];
     int fd = open("delete", O_CREAT | O_WRONLY);
@@ -104,7 +101,6 @@ int test_write_ready() {
     return TEST_PASSED;
 }
 
-// Test case 3: Timeout handling
 int test_timeout() {
     struct pollfd fds[1];
     int pipefd[2];
@@ -132,7 +128,7 @@ int test_timeout() {
     
     if (elapsed < TIMEOUT_MS/1000 - 1 || elapsed > TIMEOUT_MS/1000 + 1) {
         fprintf(stderr, "Timeout duration incorrect: %ld seconds\n", elapsed);
-        fprintf(stderr, "Fix Timeout\n"); // yes an actual fix must be made to poll.c
+        fprintf(stderr, "Fix Timeout\n");
         close(pipefd[0]);
         close(pipefd[1]);
         return TEST_FAILED;
@@ -143,11 +139,10 @@ int test_timeout() {
     return TEST_PASSED;
 }
 
-// Test case 4: Invalid file descriptor
 int test_invalid_fd() {
     struct pollfd fds[1];
     
-    fds[0].fd = 17;//-1;  // Invalid FD
+    fds[0].fd = 17;
     fds[0].events = POLLIN;
     
     int ret = poll(fds, 1, TIMEOUT_MS);
@@ -166,36 +161,6 @@ int test_invalid_fd() {
     return TEST_PASSED;
 }
 
-// Test case 5: ppoll with signal mask probs will not compile in phase 1 of libmingw32_extended only phase 2 since signal.h must be overrided to work
-//int test_ppoll_sigmask() {
-//    struct pollfd fds[1];
-//    sigset_t mask, orig_mask;
-//    struct timespec timeout = { .tv_sec = TIMEOUT_MS / 1000, .tv_nsec = 0 };
-//    
-//    // Block SIGUSR1
-//    sigemptyset(&mask);
-//    sigaddset(&mask, SIGUSR1);
-//    if (sigprocmask(SIG_BLOCK, &mask, &orig_mask) < 0) {
-//        perror("sigprocmask failed");
-//        return TEST_FAILED;
-//    }
-//    
-//    fds[0].fd = STDIN_FILENO;
-//    fds[0].events = POLLIN;
-//    
-//    // Should return immediately since signal is blocked
-//    int ret = ppoll(fds, 1, &timeout, &mask);
-//    if (ret < 0) {
-//        perror("ppoll() failed");
-//        sigprocmask(SIG_SETMASK, &orig_mask, NULL);
-//        return TEST_FAILED;
-//    }
-//    
-//    sigprocmask(SIG_SETMASK, &orig_mask, NULL);
-//    return TEST_PASSED;
-//}
-
-// Test case 6: Multiple file descriptors
 int test_multiple_fds() {
     int pipe1[2], pipe2[2];
     struct pollfd fds[2];
@@ -205,12 +170,10 @@ int test_multiple_fds() {
         return TEST_FAILED;
     }
     
-    // Set up first pipe (readable)
     fds[0].fd = pipe1[0];
     fds[0].events = POLLIN;
     write(pipe1[1], "test", 4);
     
-    // Set up second pipe (writable)
     fds[1].fd = pipe2[1];
     fds[1].events = POLLOUT;
     
@@ -241,12 +204,250 @@ int test_multiple_fds() {
     return passed;
 }
 
+int test_pipe_hangup() {
+    int pipefd[2];
+    struct pollfd fds[1];
+    
+    if (pipe(pipefd) < 0) {
+        perror("pipe creation failed");
+        return TEST_FAILED;
+    }
+    
+    fds[0].fd = pipefd[0];
+    fds[0].events = POLLIN;
+    
+    close(pipefd[1]);
+    
+    int ret = poll(fds, 1, TIMEOUT_MS);
+    printf("Pipe hangup: revents = %s\n", describe_events(fds[0].revents));
+    
+    close(pipefd[0]);
+    
+    if (ret <= 0 || !(fds[0].revents & POLLHUP)) {
+        fprintf(stderr, "POLLHUP not detected\n");
+        return TEST_FAILED;
+    }
+    
+    return TEST_PASSED;
+}
+
+int test_mixed_events() {
+    int pipe1[2], pipe2[2];
+    struct pollfd fds[3];
+    
+    if (pipe(pipe1) < 0 || pipe(pipe2) < 0) {
+        perror("pipe creation failed");
+        return TEST_FAILED;
+    }
+    
+    fds[0].fd = pipe1[0];
+    fds[0].events = POLLIN;
+    write(pipe1[1], "test", 4);
+    
+    fds[1].fd = pipe2[1];
+    fds[1].events = POLLOUT;
+    
+    fds[2].fd = 999;
+    fds[2].events = POLLIN;
+    
+    int ret = poll(fds, 3, TIMEOUT_MS);
+    printf("Mixed events: %d ready\n", ret);
+    
+    for (int i = 0; i < 3; i++) {
+        printf("  FD %d: revents = %s\n", fds[i].fd, describe_events(fds[i].revents));
+    }
+    
+    close(pipe1[0]); close(pipe1[1]);
+    close(pipe2[0]); close(pipe2[1]);
+    
+    return ret >= 2 ? TEST_PASSED : TEST_FAILED;
+}
+
+int test_zero_timeout() {
+    int pipefd[2];
+    struct pollfd fds[1];
+    
+    if (pipe(pipefd) < 0) {
+        perror("pipe creation failed");
+        return TEST_FAILED;
+    }
+    
+    fds[0].fd = pipefd[0];
+    fds[0].events = POLLIN;
+    
+    time_t start = time(NULL);
+    int ret = poll(fds, 1, 0);
+    time_t elapsed = time(NULL) - start;
+    
+    printf("Zero timeout: returned %d in %ld seconds\n", ret, elapsed);
+    
+    close(pipefd[0]);
+    close(pipefd[1]);
+    
+    if (ret != 0 || elapsed > 1) {
+        fprintf(stderr, "Zero timeout failed\n");
+        return TEST_FAILED;
+    }
+    
+    return TEST_PASSED;
+}
+
+int test_socket_read() {
+    int server_fd, client_fd, conn_fd;
+    struct sockaddr_in addr;
+    socklen_t addr_len = sizeof(addr);
+    
+    server_fd = socket(AF_INET, SOCK_STREAM, 0);
+    if (server_fd < 0) {
+        perror("socket creation failed");
+        return TEST_FAILED;
+    }
+    
+    addr.sin_family = AF_INET;
+    addr.sin_addr.s_addr = INADDR_ANY;
+    addr.sin_port = 0;
+    
+    if (bind(server_fd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
+        perror("bind failed");
+        close(server_fd);
+        return TEST_FAILED;
+    }
+    
+    if (listen(server_fd, 1) < 0) {
+        perror("listen failed");
+        close(server_fd);
+        return TEST_FAILED;
+    }
+    
+    if (getsockname(server_fd, (struct sockaddr*)&addr, &addr_len) < 0) {
+        perror("getsockname failed");
+        close(server_fd);
+        return TEST_FAILED;
+    }
+    
+    client_fd = socket(AF_INET, SOCK_STREAM, 0);
+    if (client_fd < 0) {
+        perror("client socket creation failed");
+        close(server_fd);
+        return TEST_FAILED;
+    }
+    
+    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+    if (connect(client_fd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
+        perror("connect failed");
+        close(server_fd);
+        close(client_fd);
+        return TEST_FAILED;
+    }
+    
+    conn_fd = accept(server_fd, NULL, NULL);
+    if (conn_fd < 0) {
+        perror("accept failed");
+        close(server_fd);
+        close(client_fd);
+        return TEST_FAILED;
+    }
+    
+    if (send(client_fd, "test", 4, 0) < 0) {
+        perror("send failed");
+        close(server_fd);
+        close(client_fd);
+        close(conn_fd);
+        return TEST_FAILED;
+    }
+    
+    struct pollfd fds[1];
+    fds[0].fd = conn_fd;
+    fds[0].events = POLLIN;
+    
+    int ret = poll(fds, 1, TIMEOUT_MS);
+    printf("Socket read: revents = %s\n", describe_events(fds[0].revents));
+    
+    close(server_fd);
+    close(client_fd);
+    close(conn_fd);
+    
+    if (ret <= 0 || !(fds[0].revents & POLLIN)) {
+        fprintf(stderr, "Socket read test failed\n");
+        return TEST_FAILED;
+    }
+    
+    return TEST_PASSED;
+}
+
+int test_socket_write() {
+    int sock_fd;
+    struct sockaddr_in addr;
+    
+    sock_fd = socket(AF_INET, SOCK_STREAM, 0);
+    if (sock_fd < 0) {
+        perror("socket creation failed");
+        return TEST_FAILED;
+    }
+    
+    addr.sin_family = AF_INET;
+    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+    addr.sin_port = htons(80);
+    
+    struct pollfd fds[1];
+    fds[0].fd = sock_fd;
+    fds[0].events = POLLOUT;
+    
+    int ret = poll(fds, 1, 1000);
+    printf("Socket write: revents = %s\n", describe_events(fds[0].revents));
+    
+    close(sock_fd);
+    
+    if (ret < 0) {
+        fprintf(stderr, "Socket write test failed\n");
+        return TEST_FAILED;
+    }
+    
+    return TEST_PASSED;
+}
+
+int test_ppoll_basic() {
+    int pipefd[2];
+    struct pollfd fds[1];
+    struct timespec timeout = {2, 0};
+    
+    if (pipe(pipefd)) {
+        perror("pipe creation failed");
+        return TEST_FAILED;
+    }
+    
+    fds[0].fd = pipefd[0];
+    fds[0].events = POLLIN;
+    
+    write(pipefd[1], "test", 4);
+    
+    int ret = ppoll(fds, 1, &timeout, NULL);
+    if (ret <= 0) {
+        perror("ppoll() failed for readable pipe");
+        close(pipefd[0]);
+        close(pipefd[1]);
+        return TEST_FAILED;
+    }
+    
+    printf("ppoll basic: revents = %s\n", describe_events(fds[0].revents));
+    
+    if (!(fds[0].revents & POLLIN)) {
+        fprintf(stderr, "POLLIN not set for readable pipe\n");
+        close(pipefd[0]);
+        close(pipefd[1]);
+        return TEST_FAILED;
+    }
+    
+    close(pipefd[0]);
+    close(pipefd[1]);
+    return TEST_PASSED;
+}
+
 int main() {
     int failures = 0;
     
-    printf("===== Starting poll.h test suite =====\n");
+    printf("===== Enhanced poll.h test suite =====\n");
     
-    // Run test cases
     printf("\n[TEST] Read readiness test\n");
     failures += test_read_ready();
     
@@ -262,8 +463,23 @@ int main() {
     printf("\n[TEST] Multiple FDs test\n");
     failures += test_multiple_fds();
     
-    //1printf("\n[TEST] ppoll with signal mask\n");
-    //failures += test_ppoll_sigmask();
+    printf("\n[TEST] Pipe hangup test\n");
+    failures += test_pipe_hangup();
+    
+    printf("\n[TEST] Mixed events test\n");
+    failures += test_mixed_events();
+    
+    printf("\n[TEST] Zero timeout test\n");
+    failures += test_zero_timeout();
+    
+    printf("\n[TEST] Socket read test\n");
+    failures += test_socket_read();
+    
+    printf("\n[TEST] Socket write test\n");
+    failures += test_socket_write();
+    
+    printf("\n[TEST] ppoll basic test\n");
+    failures += test_ppoll_basic();
     
     printf("\n===== Test suite completed =====\n");
     printf("%d tests failed\n", failures);
